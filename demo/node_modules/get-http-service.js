
module.exports = get_service

// @TODO: try to send some requests in parallel and see if they all resolve correctly

async function get_service ({controller = new AbortController(), vm }) {
  const provision = await vm({controller})
  const to = provision.url
  const by = location.href
  var id = 0
  const send = provision(script, onmessage)
  const pending = {}
  var _resolve
  var _reject
  var exited

  // const button = document.createElement('button')
  // button.innerHTML = 'focus: ' + provision.id
  // button.onclick = () => window.open('', provision.id)
  // document.body.append(button)
  const action = {
    'exit'  : message => {
      exited = true
      console.error('ABORT', message)
      controller.abort('exiting VM');
    },
    'fail'  : message => {
      Object.keys(pending).map(key => {
        const { message:sent_msg, resolve, timeout } = pending[key]
        clearTimeout(timeout)
        resolve({ type: 'fail', refs: { cause: sent_msg.head }, data: { request: sent_msg, response: message } })
      })
    },
    'data'  : message => {
      const { resolve, timeout } = pending[message.refs.cause]
      clearTimeout(timeout)
      resolve({ type: 'data', data: message.data })
    },
    'init'  : message => {
      get.help = message.data
      Object.freeze(get)
      action.init = resolve = _reject = void _resolve(get)
    }
  }

  return new Promise((resolve, reject) => {
    _resolve = resolve
    _reject = reject
  })
  function get (url) {
    if (exited) return
    const head = [by, to, id++]
    const type = 'get'
    const data = url
    const message = { head, refs: {}, type, data, meta: { time: Date.now(), stack: new Error().stack } }
    send(message)
    return new Promise((resolve, reject) => {
      pending[head] = { message, resolve, reject, timeout: setTimeout(() => {
        pending[head] = null
        // @TODO: check if postMessage supports "abort"
        const error = { type: 'fail', refs: { cause: message.head }, data: { info: 'request timeout', message } }
        resolve(error)
      }, 5000)}
    })
  }
  function onmessage (message) {
    const handler = action[message.type]
    if (!handler) {
      controller.abort('get-service received invalid message')
      action.exit({ type: 'exit', data: { type: 'invalid', message } })
    }
    handler(message)
  }
  function script (url, name) {
    const forigin = new URL(url).origin
    const context = (opener || parent)
    const send = (d, o = '*', t) => context.postMessage(d, o, t)
    const by = location.href
    var mid = 0
    localStorage.command = ''
    async function grab (callback) {
      callback()
      const { command } = localStorage
      if (!command) return
      const { msg, req } = JSON.parse(command)
      const request =  (typeof req === 'string') ? { url: req } : req
      try {
        const response = await fetch(request.url, request)
        const blob = await response.blob()
        const data = {}
        data.url = response.url
        data.type = response.type
        data.status = response.status
        data.statusText = response.statusText
        data.redirected = response.redirected
        data.ok = response.ok
        data.headers = [...response.headers].reduce(to_object, {})
        data.blob = blob
        msg.data = data
      } catch (error) {
        msg.type = 'fail'
        msg.data = { text: error.toString(), stack: `${error.stack}` }
      }
      localStorage.command = ''
      send(msg)
    }
    function to_object (obj, x) { obj[x[0]] = x[1]; return obj }
    const action = {
      'exit': () => window.close(),
      'fail': message => send({ type: 'fail', data: message }),
      'get': async nessage => {
        grab(async () => {
          const { head, data: request } = nessage
          const [to, by] = head
          localStorage.command = JSON.stringify({
            msg: {
              head: [by, to, mid++],
              refs: { cause: head },
              type: 'data',
            },
            req: request
          })
        }, 0)
      }
    }
    onmessage = event => {
      const { data: message, origin } = event
      if (origin !== forigin) return
      const handler = action[message.type] || action['fail']
      handler(message)
    }

    // const button = document.createElement('button')
    // button.innerHTML = 'focus: ' + name
    // button.onclick = () =>  window.open('', name)
    // document.body.append(button)
    // console.log('FOCUS BACK')
    // // const btn = [...document.body.querySelectorAll('button')].at(-1)
    // // setTimeout(() => btn.click(), 1000)

    const time = `${Date.now()}`
    const stack = `${new Error().stack}`
    ;(opener || parent).postMessage(({
      head: [by, url, mid++],
      refs: { },
      type: 'init',
      data: Object.keys(action),
      meta: { time, stack },
    }), '*')
    // send({
    //   head: [by, url, mid++],
    //   refs: { },
    //   type: 'init',
    //   data: Object.keys(action),
    //   meta: { time: Date.now(), stack: new Error().stack },
    // })
  }
}